<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RGB Color Guessing Game with Firework</title>
    <style>
		body {
			font-family: Arial, sans-serif;
			text-align: center;
			padding-top: 50px;
			user-select: none; /* Prevent text selection */
			background-color: black; /* Set background to black */
			color: white; /* Set text color to white */
		}
		.color-box {
			display: inline-block;
			width: 100px;
			height: 100px;
			margin: 10px;
			cursor: pointer;
			border-radius: 8px;
			border: none; /* Ensure border is removed */
			background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), rgba(0, 0, 0, 0.2)); /* Gradient for 3D effect */
			/* Remove the box-shadow line */
			/* box-shadow: inset 0px 0px 0px 5px ${darkerColor}, 3px 3px 8px rgba(0, 0, 0, 0.5); */
		}
        #message {
            margin-top: 20px;
            font-size: 20px;
        }
        #rgbValue {
            font-size: 24px;
            font-weight: bold;
        }
		#fireworkCanvas {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 0; /* Set this to a lower value */
			pointer-events: none;
		}
		#rgbValue, #choices, #message {
			position: relative; /* Ensure elements are positioned relative to their normal flow */
			z-index: 1; /* Set this higher than the canvas */
		}
		h1, p {
			position: relative; /* Ensure elements are positioned relative */
			z-index: 1; /* Set this higher than the canvas to keep text in front */
			color: white; /* Keep text color consistent with the other elements */
		}
		#fullscreenButton {
			position: fixed; /* Keep the button fixed in place */
			bottom: 20px; /* Space from the bottom */
			right: 20px; /* Space from the right */
			padding: 5px 10px; /* Smaller padding */
			font-size: 14px; /* Smaller font size */
			background-color: #007bff;
			color: white;
			border: none;
			border-radius: 5px;
			cursor: pointer;
			z-index: 2; /* Ensure it stays above the canvas */
		}
}

    </style>
</head>
<body>
    <h1>RGB Color Guessing Game</h1>
    <p>Guess the color based on the RGB value below:</p>
    <div id="rgbValue">RGB(?, ?, ?)</div>

    <div id="choices"></div>

    <div id="message"></div>
	<button id="fullscreenButton">Go Fullscreen</button>

    <canvas id="fireworkCanvas"></canvas>
	
	    <!-- Add audio element for firework sound -->
    <audio id="fireworkSound" src="boom.ogg" preload="auto"></audio>

    <script>
        const canvas = document.getElementById('fireworkCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        let disableClick = false;

        // Array to hold active fireworks
        const fireworks = [];
		
		document.getElementById('fullscreenButton').addEventListener('click', () => {
			const elem = document.documentElement; // Fullscreen the entire page

			// Request fullscreen
			if (elem.requestFullscreen) {
				elem.requestFullscreen();
			} else if (elem.mozRequestFullScreen) { // Firefox
				elem.mozRequestFullScreen();
			} else if (elem.webkitRequestFullscreen) { // Chrome, Safari and Opera
				elem.webkitRequestFullscreen();
			} else if (elem.msRequestFullscreen) { // IE/Edge
				elem.msRequestFullscreen();
			}
		});
		
		function updateCollisionBoxes() {
			colorBlocks = Array.from(document.querySelectorAll('.color-box')).map(box => {
				const rect = box.getBoundingClientRect();
				return {
					x: rect.left,
					y: rect.top,
					width: rect.width,
					height: rect.height
				};
			});
		}

		// Event listeners to handle fullscreen changes
		document.addEventListener('fullscreenchange', toggleFullscreenButton);
		document.addEventListener('webkitfullscreenchange', toggleFullscreenButton);
		document.addEventListener('mozfullscreenchange', toggleFullscreenButton);
		document.addEventListener('msfullscreenchange', toggleFullscreenButton);
		
		function toggleFullscreenButton() {
			const fullscreenButton = document.getElementById('fullscreenButton');
			if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
				fullscreenButton.style.display = 'none'; // Hide button in fullscreen mode
			} else {
				fullscreenButton.style.display = 'block'; // Show button when not in fullscreen mode
			}
		}

        // Get all color blocks for collision detection
        let colorBlocks = [];
		
		        // Reference to the audio element
        const fireworkSound = document.getElementById('fireworkSound');

        // Generate random RGB color
        function getRandomColor() {
            const r = Math.floor(Math.random() * 256);
            const g = Math.floor(Math.random() * 256);
            const b = Math.floor(Math.random() * 256);
            return { r, g, b };
        }

        // Generate a random integer
        function getRandomInt(max) {
            return Math.floor(Math.random() * max);
        }

        // Function to calculate a darker shade of the color for 3D effect
        function getDarkerColor(color) {
            return `rgb(${Math.max(0, color.r - 50)}, ${Math.max(0, color.g - 50)}, ${Math.max(0, color.b - 50)})`;
        }

        // Set up the game
        function setupGame() {
            const color = getRandomColor();
            const colorToGuess = `rgb(${color.r}, ${color.g}, ${color.b})`;
            document.getElementById('rgbValue').textContent = colorToGuess.toUpperCase();
            
            const choicesContainer = document.getElementById('choices');
            choicesContainer.innerHTML = '';

            // Pick the correct choice index randomly
            const correctIndex = getRandomInt(3);

            // Create 3 color options
            for (let i = 0; i < 3; i++) {
                const colorBox = document.createElement('div');
                colorBox.classList.add('color-box');

                // The correct color goes into the correct box
                let boxColor;
                if (i === correctIndex) {
                    boxColor = color;
                    colorBox.style.backgroundColor = colorToGuess;
                    colorBox.dataset.correct = "true";
                } else {
                    boxColor = getRandomColor();
                    colorBox.style.backgroundColor = `rgb(${boxColor.r}, ${boxColor.g}, ${boxColor.b})`;
                }

				// Change this section to use a fixed dark gray color for the border:
				colorBox.style.boxShadow = `
					inset 0px 0px 0px 3px rgba(50, 50, 50, 0.8), /* Light border */
					inset 0px 0px 10px rgba(255, 255, 255, 1) /* Gradient effect for depth */
				`;



                colorBox.addEventListener('click', function () {
                    checkAnswer(this);
                });

                choicesContainer.appendChild(colorBox);
            }

            // Update colorBlocks with the current color boxes positions
			updateCollisionBoxes();
        }

		// Play firework explosion sound with clones
		function playFireworkSound() {
			const soundClone = fireworkSound.cloneNode(); // Clone the audio element
			soundClone.play(); // Play the cloned sound
		}

        // Firework explosion effect with multicolor and fading particles
        function firework(x, y) {
            const particles = [];
            const particleCount = 200; // Increase the number of particles
            const gravity = 0.05; // Gravity acceleration
            const explosionRadius = 6; // Larger explosion radius

			playFireworkSound(); // Play the sound when a firework is triggered

            for (let i = 0; i < particleCount; i++) {
                const color = getRandomColor();
                const angle = Math.random() * Math.PI * 2; // Random angle for circular spread
                const speed = Math.random() * explosionRadius; // Random speed for spread radius
                const vx = Math.cos(angle) * speed; // Horizontal velocity based on angle
                const vy = Math.sin(angle) * speed; // Vertical velocity based on angle
                const elasticity = Math.random() * 0.5 + 0.5; // Random elasticity between 0.5 and 1.0
                const size = Math.random() * 2 + 1; // Random size between 1 and 3

                particles.push({
                    x: x,
                    y: y,
                    vx: vx,
                    vy: vy,
                    color: `rgba(${color.r}, ${color.g}, ${color.b}, 1)`,
                    alpha: 1, // Start fully opaque
                    life: Math.random() * 300 + 200, // Much longer lifespan
                    maxLife: Math.random() * 300 + 200, // Total life for fading calculation
                    gravity: gravity, // Add gravity effect
                    elasticity: elasticity, // Random elasticity effect for color blocks
                    groundElasticity: 0.2, // Lower elasticity specifically for bouncing off the bottom of the screen
                    bounceCount: 0, // Track the number of bounces
                    size: size // Random size for particles
                });
            }

            fireworks.push(particles); // Add this firework to the list of active fireworks
        }

        // Check and handle collisions between particles and color blocks
        function handleCollision(particle) {
            for (let block of colorBlocks) {
                if (
                    particle.x > block.x &&
                    particle.x < block.x + block.width &&
                    particle.y > block.y &&
                    particle.y < block.y + block.height
                ) {
                    // Determine which side of the block the particle has collided with
                    const dxLeft = Math.abs(particle.x - block.x);
                    const dxRight = Math.abs(particle.x - (block.x + block.width));
                    const dyTop = Math.abs(particle.y - block.y);
                    const dyBottom = Math.abs(particle.y - (block.y + block.height));

                    const minDist = Math.min(dxLeft, dxRight, dyTop, dyBottom);

                    // Bounce off the closest side
                    if (minDist === dxLeft || minDist === dxRight) {
                        particle.vx *= -particle.elasticity; // Reverse horizontal velocity
                        particle.x += (minDist === dxLeft ? -1 : 1); // Prevent sticking by adjusting position
                    } else {
                        particle.vy *= -particle.elasticity; // Reverse vertical velocity
                        particle.y += (minDist === dyTop ? -1 : 1); // Prevent sticking by adjusting position
                    }

                    particle.bounceCount++; // Increment bounce count
                }
            }
        }

        // Animate all fireworks
        function animateFireworks() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Iterate through all fireworks and animate them
            fireworks.forEach((particles, index) => {
                particles.forEach(particle => {
                    if (particle.life > 0) {
                        // Only start fading after the particle has bounced at least twice
                        if (particle.bounceCount >= 2) {
                            const fadeStart = particle.maxLife * 0.9; // Start fading later to last longer
                            const fadeEnd = particle.maxLife; // End of life
                            const fadeProgress = Math.max(0, (particle.life - fadeStart) / (fadeEnd - fadeStart));
                            particle.alpha = fadeProgress; // Alpha fades out after two bounces
                        } else {
                            particle.alpha = 1; // Fully opaque before two bounces
                        }

                        ctx.fillStyle = `rgba(${parseInt(particle.color.slice(5, 8))}, ${parseInt(particle.color.slice(10, 13))}, ${parseInt(particle.color.slice(15, 18))}, ${particle.alpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2); // Draw particles with varying sizes
                        ctx.fill();

                        // Update particle position with gravity effect
                        particle.vy += particle.gravity; // Increase vertical velocity due to gravity
                        particle.x += particle.vx;
                        particle.y += particle.vy;

                        // Bounce off the bottom of the canvas with low elasticity
                        if (particle.y >= canvas.height) {
                            particle.y = canvas.height; // Reset to the bottom
                            particle.vy *= -particle.groundElasticity * particle.elasticity; // Reverse velocity with low energy loss
                            particle.vx *= particle.elasticity; // Reduce horizontal velocity as well
                            particle.bounceCount++; // Increment bounce count
                        }

                        // Handle collisions with color blocks
                        handleCollision(particle);

                        particle.life--;
                    }
                });

                // Remove particles that are all dead
                fireworks[index] = particles.filter(p => p.life > 0);
            });

            // Remove any fireworks that have no particles left
            while (fireworks.length && fireworks[0].length === 0) {
                fireworks.shift();
            }

            requestAnimationFrame(animateFireworks);
        }

        // Function to trigger multiple firework explosions in quick succession
        function triggerMultipleFireworks(x, y) {
            const explosions = 5; // Number of explosions
            const interval = 100; // Interval in milliseconds between explosions
            for (let i = 0; i < explosions; i++) {
                setTimeout(() => {
                    firework(x, y);
                }, i * interval);
            }
        }

        // Check if the selected answer is correct
        function checkAnswer(selectedBox) {
            if (disableClick) return;
            const isCorrect = selectedBox.dataset.correct === "true";
            const message = document.getElementById('message');
            
            if (isCorrect) {
                message.textContent = "Correct! You guessed the color!";
                message.style.color = "green";

                // Get the position of the selected box
                const rect = selectedBox.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top - 10; // Position explosions slightly above the box

                // Trigger 5 firework explosions in quick succession
                triggerMultipleFireworks(x, y);
            } else {
                message.textContent = "Wrong! Try again!";
                message.style.color = "red";
            }

            // Restart the game after a short delay
            disableClick = true;
            setTimeout(() => {
                disableClick = false;
                message.textContent = "";
                setupGame();
            }, 1000);
        }

        // Start the game when the page loads
        setupGame();

        // Adjust canvas size on window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
			updateCollisionBoxes(); // Recalculate collision boxes positions on resize
        });

        // Firework effect anywhere on click, except on color boxes
        document.addEventListener('click', (event) => {
            if (!event.target.classList.contains('color-box') && event.target.id !== 'fullscreenButton') {
                firework(event.clientX, event.clientY);
            }
        });

        // Start animating fireworks
        animateFireworks();
    </script>
</body>
</html>
